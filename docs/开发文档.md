# Family Chart 深度开发文档

## 1. 架构概述

Family Chart 是一个基于 D3.js 的家谱树可视化库，采用模块化设计和状态管理架构。

### 1.1 核心设计理念

- **分离关注点**: 计算逻辑、渲染逻辑、状态管理和用户交互分离
- **模块化**: 每个功能模块独立，便于维护和扩展
- **可配置性**: 支持多种布局、样式和交互方式
- **双渲染模式**: 支持 SVG 和 HTML 两种渲染方式

### 1.2 整体架构流程

```
数据输入 → createStore → CalculateTree → View渲染 → 用户交互 → 状态更新
    ↑                                                           ↓
    └─────────────── 状态管理循环 ──────────────────────────────┘
```

## 2. 核心模块详解

### 2.1 数据计算层 (CalculateTree)

**文件**: `src/CalculateTree/CalculateTree.js`

#### 功能职责
- 树形布局计算和节点定位
- 配偶关系处理
- 父子关系建立
- 坐标系统转换

#### 核心算法

```javascript
// 主要流程
function CalculateTree({data, main_id, node_separation, level_separation, single_parent_empty_card, is_horizontal}) {
  // 1. 数据预处理
  const data_stash = single_parent_empty_card ? createRelsToAdd(data) : data
  
  // 2. 分别计算子树和祖先树
  const tree_children = calculateTreePositions(main, 'children', false)
  const tree_parents = calculateTreePositions(main, 'parents', true)
  
  // 3. 合并并调整位置
  levelOutEachSide(tree_parents, tree_children)
  const tree = mergeSides(tree_parents, tree_children)
  
  // 4. 配偶和连接线处理
  setupSpouses({tree, node_separation})
  setupProgenyParentsPos({tree})
  
  return {data: tree, data_stash, dim, main_id: main.id, is_horizontal}
}
```

#### 关键特性

1. **分离式树计算**: 
   - 子代树向下计算 (descendants)
   - 祖先树向上计算 (ancestors)
   - 在主节点处合并

2. **配偶布局算法**:
   ```javascript
   // 配偶定位逻辑
   const side = d.data.data.gender === "M" ? -1 : 1;  // 女性在右
   d.x += d.data.rels.spouses.length/2*node_separation*side;
   spouse.x = d.x-(node_separation*(i+1))*side;
   ```

3. **节点间距调整**:
   - 基础间距 (node_separation, level_separation)
   - 配偶额外间距 (offsetOnPartners)
   - 不同父母的兄弟姐妹间距调整

### 2.2 状态管理层 (createStore)

**文件**: `src/createStore.js`

#### 设计模式
采用**观察者模式**的状态管理系统:

```javascript
const store = {
  state: {
    data,           // 原始数据
    tree,           // 计算后的树结构
    main_id,        // 当前主节点ID
    main_id_history // 主节点历史记录
  },
  
  // 状态更新方法
  updateTree: (props) => {
    state.tree = calcTree();
    if (onUpdate) onUpdate(props)  // 触发视图更新
  },
  
  // 观察者注册
  setOnUpdate: (f) => onUpdate = f
}
```

#### 状态更新流程

1. **数据更新** → `updateData()` → 重新计算树结构
2. **主节点切换** → `updateMainId()` → 重新布局和渲染
3. **配置修改** → `updateTree()` → 应用新配置并渲染

### 2.3 渲染系统 (View)

**文件**: `src/view/view.js`

#### 渲染管线

```javascript
function view(tree, svg, Card, props) {
  // 1. 选择渲染模式
  if (props.cardComponent) updateCardsComponent(...)      // React/Vue组件
  else if (props.cardHtml) updateCardsHtml(...)          // HTML模式
  else updateCards(svg, tree, Card, props);              // SVG模式
  
  // 2. 更新连接线
  updateLinks(svg, tree, props);
  
  // 3. 调整视图位置
  if (props.initial) treeFit({...})
  else if (tree_position === 'main_to_middle') cardToMiddle({...})
}
```

#### 动画系统

**延迟计算**: 基于节点深度和类型计算动画延迟
```javascript
function calculateDelay(tree, d, transition_time) {
  const delay_level = transition_time * 0.4;
  let delay = d.depth * delay_level;
  
  if (d.spouse) delay += delay_level;  // 配偶额外延迟
  if (!d.is_ancestry) delay += (ancestry_levels) * delay_level;
  
  return delay;
}
```

**进入/退出动画**:
- 进入: 从计算位置淡入 + 平移
- 更新: 平滑过渡到新位置
- 退出: 淡出 + 平移到退出位置

### 2.4 卡片系统 (Cards)

#### 卡片抽象

**基类**: `CardSvg` / `CardHtml`
- 配置接口: `setCardDim()`, `setCardDisplay()`
- 事件处理: `setOnCardClick()`, `onCardUpdate()`
- 内容定制: `setCardTextSvg()`

**渲染流程**:
1. **数据绑定**: D3.js 数据绑定模式
2. **DOM操作**: enter/update/exit 生命周期
3. **样式应用**: CSS类和内联样式
4. **事件注册**: 点击、悬停等交互事件

### 2.5 事件处理系统

#### 交互层次

1. **卡片级交互**:
   ```javascript
   onCardClick(e, d) {
     this.store.updateMainId(d.data.id)
     this.store.updateTree({})
   }
   ```

2. **视图级交互**:
   - 缩放: `manualZoom()`
   - 平移: `cardToMiddle()`
   - 适应: `treeFit()`

3. **应用级交互**:
   - 数据编辑
   - 配置修改
   - 导出功能

## 3. 数据结构规范

### 3.1 输入数据格式

```javascript
const person = {
  id: "unique_id",
  data: {
    "first name": "张",
    "last name": "三",
    gender: "M",        // M/F
    "birth date": "1990-01-01",
    photo: "url_to_photo"
  },
  rels: {
    father: "father_id",
    mother: "mother_id",
    spouses: ["spouse_id1", "spouse_id2"],
    children: ["child_id1", "child_id2"]
  }
}
```

### 3.2 计算后数据结构

```javascript
const treeNode = {
  data: person,           // 原始人员数据
  x: 100, y: 200,        // 计算后的坐标
  depth: 1,              // 节点深度
  is_ancestry: false,    // 是否为祖先节点
  added: false,          // 是否为自动添加的配偶
  
  // 关系引用
  parent: parentNode,
  children: [childNode1, childNode2],
  parents: [father, mother],
  spouses: [spouse1, spouse2],
  
  // 连接线坐标
  psx: 150, psy: 250,    // 连接到父母的起始点
}
```

## 4. 扩展开发指南

### 4.1 自定义卡片

**创建自定义SVG卡片**:
```javascript
function CustomCard(store, svg, cardData) {
  const card_dim = {w: 200, h: 80, text_x: 10, text_y: 20};
  
  return function(d) {
    const card = d3.select(this);
    // 自定义卡片内容渲染逻辑
    card.html(`<rect width="${card_dim.w}" height="${card_dim.h}"/>
               <text x="${card_dim.text_x}" y="${card_dim.text_y}">
                 ${d.data.data["first name"]}
               </text>`);
  }
}
```

**创建HTML卡片**:
```javascript
function CustomHtmlCard(d) {
  return `
    <div class="custom-card">
      <img src="${d.data.data.photo}" alt="照片">
      <div class="card-info">
        <h3>${d.data.data["first name"]} ${d.data.data["last name"]}</h3>
        <p>生日: ${d.data.data["birth date"]}</p>
      </div>
    </div>
  `;
}
```

### 4.2 自定义布局算法

**修改节点间距算法**:
```javascript
// 在 CalculateTree.js 中修改 separation 函数
function separation(a, b) {
  let offset = 1;
  
  // 自定义间距逻辑
  if (customCondition(a, b)) {
    offset += customOffset;
  }
  
  return offset;
}
```

### 4.3 添加新的交互功能

**示例: 添加双击编辑功能**:
```javascript
CardSvg.prototype.setOnCardDoubleClick = function(onCardDoubleClick) {
  this.onCardDoubleClick = onCardDoubleClick;
  return this;
}

// 在卡片渲染时绑定事件
card.on("dblclick", this.onCardDoubleClick);
```

## 5. 性能优化建议

### 5.1 大数据集优化

1. **虚拟化渲染**: 只渲染可见区域的节点
2. **分层加载**: 按需加载子树数据
3. **缓存计算结果**: 避免重复的布局计算

### 5.2 动画性能

1. **批量DOM操作**: 使用 D3.js 的 enter/update/exit 模式
2. **合理的动画延迟**: 避免同时启动大量动画
3. **CSS动画**: 对简单变换使用CSS而非JS动画

### 5.3 内存管理

1. **清理事件监听器**: 在节点移除时清理事件
2. **避免循环引用**: 小心处理父子节点引用
3. **及时清理DOM**: 使用 D3.js 的 remove() 方法

## 6. 调试和测试

### 6.1 调试技巧

**可视化调试**:
```javascript
// 显示节点坐标
tree.data.forEach(d => {
  console.log(`${d.data.data["first name"]}: (${d.x}, ${d.y})`);
});

// 可视化连接线数据
const links = createLinks({d: node, tree: tree.data});
console.table(links);
```

**状态检查**:
```javascript
// 检查状态一致性
const storeData = store.getData();
const treeData = store.getTree().data;
console.log("数据一致性:", storeData.length === treeData.length);
```

### 6.2 单元测试建议

1. **CalculateTree 测试**: 验证布局算法的正确性
2. **Store 测试**: 验证状态管理的一致性  
3. **渲染测试**: 使用 Cypress 进行端到端测试

### 6.3 常见问题

**问题**: 配偶位置重叠
**解决**: 检查 `offsetOnPartners` 函数的计算逻辑

**问题**: 动画不流畅
**解决**: 减少 `transition_time` 或优化 `calculateDelay` 函数

**问题**: 大数据集渲染慢
**解决**: 实现虚拟化或分页加载

## 7. 最佳实践

### 7.1 代码规范

1. **命名约定**: 使用有意义的变量名，如 `main_id` 而非 `id`
2. **函数职责**: 每个函数只负责一个明确的功能
3. **错误处理**: 对可能出错的操作添加适当的错误检查

### 7.2 配置管理

**推荐的配置结构**:
```javascript
const defaultConfig = {
  layout: {
    node_separation: 250,
    level_separation: 150,
    is_horizontal: false
  },
  animation: {
    transition_time: 1000,
    enable_delay: true
  },
  display: {
    mini_tree: true,
    link_break: false
  }
};
```

### 7.3 扩展性设计

1. **插件系统**: 通过配置对象注入自定义功能
2. **事件系统**: 提供丰富的生命周期钩子
3. **主题系统**: 分离样式和逻辑，支持主题切换