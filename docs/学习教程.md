# Family Chart 学习教程

## 目录
1. [快速入门](#1-快速入门)
2. [核心概念](#2-核心概念)
3. [基础用法](#3-基础用法)
4. [进阶功能](#4-进阶功能)
5. [实战项目](#5-实战项目)
6. [常见问题](#6-常见问题)

## 1. 快速入门

### 1.1 第一个家谱图

**步骤一**: 准备HTML容器
```html
<!DOCTYPE html>
<html>
<head>
  <title>我的家谱图</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="path/to/family-chart.js"></script>
  <link rel="stylesheet" href="path/to/family-chart.css">
</head>
<body>
  <div id="FamilyChart"></div>
</body>
</html>
```

**步骤二**: 准备家族数据
```javascript
const familyData = [
  {
    id: "father",
    data: {
      "first name": "李",
      "last name": "明",
      gender: "M",
      "birth date": "1970-05-15"
    },
    rels: {
      spouses: ["mother"],
      children: ["son", "daughter"]
    }
  },
  {
    id: "mother", 
    data: {
      "first name": "王",
      "last name": "丽",
      gender: "F",
      "birth date": "1972-08-20"
    },
    rels: {
      spouses: ["father"],
      children: ["son", "daughter"]
    }
  },
  {
    id: "son",
    data: {
      "first name": "李",
      "last name": "强",
      gender: "M", 
      "birth date": "1995-03-10"
    },
    rels: {
      father: "father",
      mother: "mother"
    }
  },
  {
    id: "daughter",
    data: {
      "first name": "李",
      "last name": "娜",
      gender: "F",
      "birth date": "1998-12-05"
    },
    rels: {
      father: "father", 
      mother: "mother"
    }
  }
];
```

**步骤三**: 创建家谱图
```javascript
// 方法一：使用简单API
const chart = f3.createChart(
  document.querySelector("#FamilyChart"),
  familyData
);

// 方法二：使用完整配置
const store = f3.createStore({
  data: familyData,
  node_separation: 250,
  level_separation: 150
});

const svg = f3.createSvg(document.querySelector("#FamilyChart"));
const card = f3.CardSvg(document.querySelector("#FamilyChart"), store);

store.setOnUpdate(props => {
  f3.view(store.getTree(), svg, card.getCard(), props);
});

store.updateTree({});
```

### 1.2 理解输出结果

运行上述代码后，你会看到：
- 父母在上层，以配偶关系连接
- 子女在下层，通过连接线与父母相连
- 点击任何卡片可以切换视图中心
- 支持鼠标滚轮缩放和拖拽

## 2. 核心概念

### 2.1 数据模型

**人员对象 (Person)**:
```javascript
{
  id: "唯一标识符",           // 必需：全局唯一ID
  data: {                    // 必需：个人信息
    "first name": "姓",
    "last name": "名", 
    gender: "M|F",          // 性别：M(男)/F(女)
    "birth date": "YYYY-MM-DD",
    photo: "图片URL",
    // ... 其他自定义字段
  },
  rels: {                   // 必需：关系信息
    father: "父亲ID",
    mother: "母亲ID", 
    spouses: ["配偶ID数组"],
    children: ["子女ID数组"]
  }
}
```

**关系规则**:
1. 每个人必须有唯一的 `id`
2. `rels` 中的ID必须在数据集中存在
3. 关系是双向的：如果A是B的父亲，B必须在A的children中
4. 配偶关系是互相的：如果A是B的配偶，B也必须是A的配偶

### 2.2 架构组件

**Store (状态管理)**:
- 管理数据状态和树结构
- 处理主节点切换
- 维护历史记录

**CalculateTree (布局计算)**:
- 计算节点位置
- 处理配偶布局
- 生成连接线数据

**View (视图渲染)**:
- 渲染卡片和连接线
- 处理动画效果
- 管理DOM更新

**Card (卡片组件)**:
- 定义卡片外观
- 处理用户交互
- 支持自定义内容

### 2.3 坐标系统

```
祖先代 (负Y)  ←→  node_separation (水平间距)
     ↑
level_separation (垂直间距)  
     ↓
当前代 (Y=0)
     ↓
后代代 (正Y)
```

## 3. 基础用法

### 3.1 自定义卡片样式

**修改卡片尺寸**:
```javascript
card.setCardDim({
  w: 200,        // 宽度
  h: 80,         // 高度
  text_x: 10,    // 文字X偏移
  text_y: 20,    // 文字Y偏移
  img_w: 50,     // 图片宽度
  img_h: 50      // 图片高度
});
```

**自定义显示内容**:
```javascript
card.setCardDisplay([
  d => `${d.data["first name"]} ${d.data["last name"]}`,
  d => `生日: ${d.data["birth date"]}`,
  d => d.data.profession || "职业未知"
]);
```

**自定义SVG内容**:
```javascript
card.setCardTextSvg(d => `
  <text x="75" y="15" class="name">${d["first name"]} ${d["last name"]}</text>
  <text x="75" y="35" class="date">${d["birth date"]}</text>
  <text x="75" y="55" class="profession">${d.profession || ''}</text>
`);
```

### 3.2 布局配置

**调整间距**:
```javascript
const store = f3.createStore({
  data: familyData,
  node_separation: 300,    // 水平间距
  level_separation: 200,   // 垂直间距
  is_horizontal: false     // 垂直布局
});
```

**水平布局**:
```javascript
const store = f3.createStore({
  data: familyData,
  is_horizontal: true      // 改为水平布局
});
```

**处理单亲家庭**:
```javascript
const store = f3.createStore({
  data: familyData,
  single_parent_empty_card: true  // 自动添加空配偶卡片
});
```

### 3.3 交互功能

**自定义点击事件**:
```javascript
card.setOnCardClick((event, datum) => {
  console.log('点击了:', datum.data["first name"]);
  
  // 切换主节点
  store.updateMainId(datum.data.id);
  store.updateTree({
    tree_position: 'main_to_middle',  // 居中显示
    transition_time: 1000
  });
});
```

**添加悬停效果**:
```javascript
card.setOnCardUpdate(function(d) {
  const cardElement = d3.select(this);
  
  cardElement
    .on('mouseenter', function() {
      d3.select(this).style('stroke', '#007bff').style('stroke-width', 3);
    })
    .on('mouseleave', function() {
      d3.select(this).style('stroke', '#ccc').style('stroke-width', 1);
    });
});
```

### 3.4 视图控制

**适应容器大小**:
```javascript
store.updateTree({
  tree_position: 'fit',
  transition_time: 1000
});
```

**手动缩放**:
```javascript
f3.manualZoom({
  amount: 1.5,        // 放大1.5倍
  svg: svg,
  transition_time: 500
});
```

**定位到特定卡片**:
```javascript
const targetDatum = store.getTreeDatum('target_id');
f3.cardToMiddle({
  datum: targetDatum,
  svg: svg,
  svg_dim: svg.getBoundingClientRect(),
  scale: 1.2,
  transition_time: 1000
});
```

## 4. 进阶功能

### 4.1 HTML卡片模式

**启用HTML渲染**:
```javascript
const htmlCard = f3.CardHtml(container, store);
htmlCard.setCardHtml(d => `
  <div class="custom-card">
    <div class="photo-container">
      <img src="${d.data.photo || 'default.jpg'}" alt="照片">
    </div>
    <div class="info-container">
      <h3>${d.data["first name"]} ${d.data["last name"]}</h3>
      <p class="birth-date">${d.data["birth date"]}</p>
      <p class="profession">${d.data.profession || ''}</p>
    </div>
  </div>
`);

store.setOnUpdate(props => {
  f3.view(store.getTree(), svg, htmlCard.getCard(), {
    ...props,
    cardHtml: container.querySelector('#htmlSvg')
  });
});
```

**HTML卡片样式**:
```css
.custom-card {
  width: 200px;
  height: 120px;
  background: #fff;
  border: 2px solid #ccc;
  border-radius: 8px;
  padding: 10px;
  display: flex;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.photo-container img {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  object-fit: cover;
}

.info-container {
  margin-left: 10px;
  flex: 1;
}

.info-container h3 {
  margin: 0 0 5px 0;
  font-size: 14px;
  color: #333;
}
```

### 4.2 动态数据更新

**添加新成员**:
```javascript
function addNewPerson(personData, parentId) {
  const data = store.getData();
  
  // 添加新人员
  data.push(personData);
  
  // 更新父母的children关系
  if (parentId) {
    const parent = data.find(p => p.id === parentId);
    if (parent) {
      if (!parent.rels.children) parent.rels.children = [];
      parent.rels.children.push(personData.id);
    }
  }
  
  // 更新数据并重新渲染
  store.updateData(data);
  store.updateTree({
    tree_position: 'fit',
    transition_time: 1000
  });
}

// 使用示例
addNewPerson({
  id: "new_child",
  data: {
    "first name": "李",
    "last name": "小明", 
    gender: "M",
    "birth date": "2020-01-01"
  },
  rels: {
    father: "father",
    mother: "mother"
  }
}, "father");
```

**删除成员**:
```javascript
function removePerson(personId) {
  let data = store.getData();
  
  // 清理关系引用
  data.forEach(person => {
    if (person.rels.father === personId) delete person.rels.father;
    if (person.rels.mother === personId) delete person.rels.mother;
    if (person.rels.spouses) {
      person.rels.spouses = person.rels.spouses.filter(id => id !== personId);
    }
    if (person.rels.children) {
      person.rels.children = person.rels.children.filter(id => id !== personId);
    }
  });
  
  // 移除人员
  data = data.filter(person => person.id !== personId);
  
  // 如果删除的是主节点，切换到其他节点
  if (store.getMainId() === personId) {
    const lastAvailable = store.getLastAvailableMainDatum();
    if (lastAvailable) store.updateMainId(lastAvailable.id);
  }
  
  store.updateData(data);
  store.updateTree({transition_time: 1000});
}
```

### 4.3 数据导入导出

**从JSON文件导入**:
```javascript
async function loadFamilyData(url) {
  try {
    const response = await fetch(url);
    const data = await response.json();
    
    // 验证数据格式
    if (validateFamilyData(data)) {
      store.updateData(data);
      store.updateTree({initial: true});
    } else {
      console.error('数据格式不正确');
    }
  } catch (error) {
    console.error('加载数据失败:', error);
  }
}

function validateFamilyData(data) {
  return Array.isArray(data) && data.every(person => 
    person.id && 
    person.data && 
    person.rels
  );
}
```

**导出为JSON**:
```javascript
function exportFamilyData() {
  const data = store.getData();
  const jsonStr = JSON.stringify(data, null, 2);
  
  // 创建下载链接
  const blob = new Blob([jsonStr], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = 'family_data.json';
  a.click();
  
  URL.revokeObjectURL(url);
}
```

**导出为图片**:
```javascript
function exportAsImage() {
  const svg = document.querySelector('svg.main_svg');
  const svgData = new XMLSerializer().serializeToString(svg);
  
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const img = new Image();
  
  img.onload = function() {
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    
    canvas.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'family_tree.png';
      a.click();
      URL.revokeObjectURL(url);
    });
  };
  
  img.src = 'data:image/svg+xml;base64,' + btoa(svgData);
}
```

## 5. 实战项目

### 5.1 完整的家谱编辑器

**项目结构**:
```
family-editor/
├── index.html
├── css/
│   └── style.css
├── js/
│   ├── main.js
│   ├── data-manager.js
│   ├── form-handler.js
│   └── export-utils.js
└── assets/
    └── default-avatar.png
```

**主要功能实现**:

```javascript
// main.js - 主控制器
class FamilyTreeEditor {
  constructor(container) {
    this.container = container;
    this.store = null;
    this.card = null;
    this.svg = null;
    this.init();
  }
  
  init() {
    this.setupUI();
    this.initFamilyChart();
    this.bindEvents();
  }
  
  setupUI() {
    this.container.innerHTML = `
      <div class="toolbar">
        <button id="add-person">添加成员</button>
        <button id="edit-person">编辑</button>
        <button id="delete-person">删除</button>
        <button id="export-json">导出数据</button>
        <button id="export-image">导出图片</button>
      </div>
      <div class="chart-container" id="chart"></div>
      <div class="form-panel" id="form-panel" style="display:none;">
        <form id="person-form">
          <input type="text" name="firstName" placeholder="姓" required>
          <input type="text" name="lastName" placeholder="名" required>
          <select name="gender" required>
            <option value="M">男</option>
            <option value="F">女</option>
          </select>
          <input type="date" name="birthDate">
          <input type="url" name="photo" placeholder="照片URL">
          <button type="submit">保存</button>
          <button type="button" id="cancel">取消</button>
        </form>
      </div>
    `;
  }
  
  initFamilyChart() {
    const chartContainer = this.container.querySelector('#chart');
    
    this.store = f3.createStore({
      data: this.loadData(),
      node_separation: 250,
      level_separation: 150
    });
    
    this.svg = f3.createSvg(chartContainer);
    this.card = f3.CardSvg(chartContainer, this.store);
    
    this.card.setOnCardClick((e, d) => {
      this.selectedPerson = d;
      this.store.updateMainId(d.data.id);
      this.store.updateTree({tree_position: 'main_to_middle'});
    });
    
    this.store.setOnUpdate(props => {
      f3.view(this.store.getTree(), this.svg, this.card.getCard(), props);
    });
    
    this.store.updateTree({initial: true});
  }
  
  loadData() {
    const saved = localStorage.getItem('family_data');
    return saved ? JSON.parse(saved) : this.getDefaultData();
  }
  
  saveData() {
    localStorage.setItem('family_data', JSON.stringify(this.store.getData()));
  }
  
  getDefaultData() {
    return [
      {
        id: "root",
        data: {
          "first name": "张",
          "last name": "三",
          gender: "M",
          "birth date": "1950-01-01"
        },
        rels: {}
      }
    ];
  }
}

// 初始化编辑器
const editor = new FamilyTreeEditor(document.querySelector('#app'));
```

### 5.2 移动端适配

**响应式布局**:
```css
/* style.css */
.chart-container {
  width: 100%;
  height: 80vh;
  overflow: hidden;
  touch-action: none; /* 防止默认触摸行为 */
}

@media (max-width: 768px) {
  .toolbar {
    flex-wrap: wrap;
    gap: 5px;
  }
  
  .toolbar button {
    font-size: 12px;
    padding: 8px 12px;
  }
  
  /* 卡片在移动端更紧凑 */
  .mobile-card {
    width: 150px !important;
    height: 60px !important;
  }
}
```

**触摸优化**:
```javascript
// 移动端专用配置
if ('ontouchstart' in window) {
  // 减小卡片间距
  store = f3.createStore({
    data: familyData,
    node_separation: 180,
    level_separation: 120
  });
  
  // 调整卡片尺寸
  card.setCardDim({
    w: 150, h: 60, 
    text_x: 5, text_y: 12,
    img_w: 40, img_h: 40
  });
  
  // 启用触摸友好的交互
  card.setOnCardClick((e, d) => {
    // 双击才切换主节点，避免误触
    if (Date.now() - this.lastClickTime < 300) {
      store.updateMainId(d.data.id);
      store.updateTree({tree_position: 'main_to_middle'});
    }
    this.lastClickTime = Date.now();
  });
}
```

## 6. 常见问题

### 6.1 数据相关问题

**Q: 关系数据不一致怎么办？**
```javascript
function validateRelationships(data) {
  const errors = [];
  
  data.forEach(person => {
    // 检查父子关系一致性
    if (person.rels.children) {
      person.rels.children.forEach(childId => {
        const child = data.find(p => p.id === childId);
        if (!child) {
          errors.push(`子女 ${childId} 不存在`);
        } else {
          const parentKey = person.data.gender === 'M' ? 'father' : 'mother';
          if (child.rels[parentKey] !== person.id) {
            errors.push(`关系不一致: ${person.id} -> ${childId}`);
          }
        }
      });
    }
    
    // 检查配偶关系一致性
    if (person.rels.spouses) {
      person.rels.spouses.forEach(spouseId => {
        const spouse = data.find(p => p.id === spouseId);
        if (!spouse || !spouse.rels.spouses?.includes(person.id)) {
          errors.push(`配偶关系不一致: ${person.id} <-> ${spouseId}`);
        }
      });
    }
  });
  
  return errors;
}
```

**Q: 如何处理复杂的再婚关系？**
```javascript
const complexFamily = [
  {
    id: "person1",
    data: { "first name": "张", "last name": "三", gender: "M" },
    rels: {
      spouses: ["person2", "person4"], // 两次婚姻
      children: ["child1", "child2", "child3"] // 来自不同配偶的子女
    }
  },
  {
    id: "child1",
    rels: {
      father: "person1",
      mother: "person2" // 第一次婚姻的子女
    }
  },
  {
    id: "child2", 
    rels: {
      father: "person1", 
      mother: "person4" // 第二次婚姻的子女
    }
  }
];
```

### 6.2 渲染性能问题

**Q: 大家族数据渲染慢怎么办？**
```javascript
// 实现分层加载
function createLazyStore(allData, maxVisibleLevels = 3) {
  let visibleData = [];
  
  function getVisibleData(mainId) {
    const main = allData.find(p => p.id === mainId);
    const visited = new Set();
    const queue = [{person: main, level: 0}];
    const result = [];
    
    while (queue.length > 0) {
      const {person, level} = queue.shift();
      
      if (level > maxVisibleLevels || visited.has(person.id)) continue;
      
      visited.add(person.id);
      result.push(person);
      
      // 添加直接关联的人员
      ['father', 'mother'].forEach(rel => {
        if (person.rels[rel]) {
          const parent = allData.find(p => p.id === person.rels[rel]);
          if (parent) queue.push({person: parent, level: level + 1});
        }
      });
      
      (person.rels.children || []).forEach(childId => {
        const child = allData.find(p => p.id === childId);
        if (child) queue.push({person: child, level: level + 1});
      });
    }
    
    return result;
  }
  
  const store = f3.createStore({
    data: getVisibleData(allData[0].id),
    node_separation: 200,
    level_separation: 120
  });
  
  // 重写 updateMainId 以支持懒加载
  const originalUpdateMainId = store.updateMainId;
  store.updateMainId = (id) => {
    const newData = getVisibleData(id);
    store.updateData(newData);
    originalUpdateMainId(id);
  };
  
  return store;
}
```

### 6.3 样式和布局问题

**Q: 如何自定义连接线样式？**
```javascript
// 修改连接线样式
function customizeLinks() {
  const svg = document.querySelector('svg.main_svg');
  
  // 选择所有连接线
  d3.select(svg).selectAll('path.link')
    .style('stroke', '#2196F3')        // 蓝色连接线
    .style('stroke-width', 3)          // 更粗的线条
    .style('stroke-dasharray', '5,5')  // 虚线样式
    .style('marker-end', 'url(#arrow)'); // 添加箭头
  
  // 添加箭头标记
  const defs = d3.select(svg).select('defs');
  defs.append('marker')
    .attr('id', 'arrow')
    .attr('viewBox', '0 -5 10 10')
    .attr('refX', 15)
    .attr('refY', 0)
    .attr('markerWidth', 6)
    .attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,-5L10,0L0,5')
    .style('fill', '#2196F3');
}
```

**Q: 如何实现主题切换？**
```javascript
// 主题管理器
class ThemeManager {
  constructor() {
    this.themes = {
      light: {
        background: '#ffffff',
        cardBorder: '#cccccc',
        cardBackground: '#ffffff',
        textColor: '#333333',
        linkColor: '#999999'
      },
      dark: {
        background: '#1a1a1a',
        cardBorder: '#555555', 
        cardBackground: '#2d2d2d',
        textColor: '#ffffff',
        linkColor: '#666666'
      }
    };
    this.currentTheme = 'light';
  }
  
  applyTheme(themeName) {
    const theme = this.themes[themeName];
    if (!theme) return;
    
    const container = document.querySelector('#chart');
    container.style.backgroundColor = theme.background;
    
    // 更新卡片样式
    container.querySelectorAll('.card_cont rect').forEach(rect => {
      rect.style.fill = theme.cardBackground;
      rect.style.stroke = theme.cardBorder;
    });
    
    // 更新文字颜色
    container.querySelectorAll('.card_cont text').forEach(text => {
      text.style.fill = theme.textColor;
    });
    
    // 更新连接线颜色
    container.querySelectorAll('path.link').forEach(path => {
      path.style.stroke = theme.linkColor;
    });
    
    this.currentTheme = themeName;
  }
  
  toggleTheme() {
    const newTheme = this.currentTheme === 'light' ? 'dark' : 'light';
    this.applyTheme(newTheme);
  }
}

const themeManager = new ThemeManager();
```

### 6.4 部署和集成问题

**Q: 如何与React集成？**
```jsx
// React组件包装
import React, { useEffect, useRef } from 'react';
import f3 from 'family-chart';

const FamilyChart = ({ data, onPersonClick }) => {
  const containerRef = useRef();
  const storeRef = useRef();
  const chartRef = useRef();
  
  useEffect(() => {
    if (!containerRef.current || !data) return;
    
    // 初始化图表
    const store = f3.createStore({
      data,
      node_separation: 250,
      level_separation: 150
    });
    
    const svg = f3.createSvg(containerRef.current);
    const card = f3.CardSvg(containerRef.current, store);
    
    card.setOnCardClick((e, d) => {
      onPersonClick?.(d.data);
      store.updateMainId(d.data.id);
      store.updateTree({tree_position: 'main_to_middle'});
    });
    
    store.setOnUpdate(props => {
      f3.view(store.getTree(), svg, card.getCard(), props);
    });
    
    store.updateTree({initial: true});
    
    storeRef.current = store;
    chartRef.current = {svg, card};
    
    return () => {
      // 清理
      containerRef.current.innerHTML = '';
    };
  }, [data]);
  
  // 数据更新
  useEffect(() => {
    if (storeRef.current && data) {
      storeRef.current.updateData(data);
      storeRef.current.updateTree({});
    }
  }, [data]);
  
  return <div ref={containerRef} style={{width: '100%', height: '600px'}} />;
};

export default FamilyChart;
```

**Q: 如何在Vue中使用？**
```vue
<template>
  <div ref="chartContainer" class="family-chart"></div>
</template>

<script>
import f3 from 'family-chart';

export default {
  name: 'FamilyChart',
  props: {
    familyData: {
      type: Array,
      required: true
    }
  },
  data() {
    return {
      store: null,
      chart: null
    };
  },
  mounted() {
    this.initChart();
  },
  watch: {
    familyData: {
      handler() {
        if (this.store) {
          this.store.updateData(this.familyData);
          this.store.updateTree({});
        }
      },
      deep: true
    }
  },
  methods: {
    initChart() {
      this.store = f3.createStore({
        data: this.familyData,
        node_separation: 250,
        level_separation: 150
      });
      
      const svg = f3.createSvg(this.$refs.chartContainer);
      const card = f3.CardSvg(this.$refs.chartContainer, this.store);
      
      card.setOnCardClick((e, d) => {
        this.$emit('person-click', d.data);
        this.store.updateMainId(d.data.id);
        this.store.updateTree({tree_position: 'main_to_middle'});
      });
      
      this.store.setOnUpdate(props => {
        f3.view(this.store.getTree(), svg, card.getCard(), props);
      });
      
      this.store.updateTree({initial: true});
      this.chart = {svg, card};
    }
  },
  beforeDestroy() {
    if (this.$refs.chartContainer) {
      this.$refs.chartContainer.innerHTML = '';
    }
  }
};
</script>

<style scoped>
.family-chart {
  width: 100%;
  height: 600px;
}
</style>
```

## 总结

通过本教程，你应该能够：

1. **理解核心概念**：掌握数据模型、架构组件和坐标系统
2. **使用基础功能**：创建家谱图、自定义样式、处理交互
3. **应用进阶功能**：HTML渲染、动态更新、数据导入导出
4. **解决常见问题**：性能优化、样式定制、框架集成

继续探索源码和示例，你将能够构建出功能强大的家谱应用！