# Family Chart 开发流程指南

## 1. 开发环境搭建

### 1.1 环境要求

**必需依赖**:
- Node.js >= 14.0
- npm 或 yarn
- 现代浏览器 (支持 ES6+)

**开发工具推荐**:
- VS Code + 相关扩展
- Git 版本控制
- Chrome DevTools

### 1.2 项目初始化

**克隆项目**:
```bash
git clone https://github.com/donatso/family-chart.git
cd family-chart
```

**安装依赖**:
```bash
npm install
# 或
yarn install
```

**验证环境**:
```bash
# 启动开发服务器
npm run dev

# 在浏览器中访问 http://localhost:8080
# 查看 examples/ 目录下的示例
```

### 1.3 项目结构理解

```
family-chart/
├── src/                    # 核心源码
│   ├── CalculateTree/      # 布局计算模块
│   ├── Cards/              # 卡片组件
│   ├── CreateTree/         # 树创建功能
│   ├── handlers/           # 事件处理
│   ├── view/               # 视图渲染
│   └── index.js            # 主入口
├── examples/               # 使用示例
├── tests/                  # 测试文件
├── dist/                   # 构建输出
└── scripts/                # 构建脚本
```

## 2. 开发工作流

### 2.1 功能开发流程

**第一步: 需求分析**
1. 明确功能需求和用户场景
2. 分析现有代码架构
3. 确定修改范围和影响

**第二步: 设计方案**
1. 画出数据流图
2. 确定API接口设计
3. 考虑向后兼容性

**第三步: 编码实现**
1. 创建功能分支
2. 按模块逐步实现
3. 编写单元测试

**第四步: 测试验证**
1. 运行现有测试
2. 在示例中验证
3. 跨浏览器测试

**第五步: 代码审查**
1. 自我审查代码质量
2. 检查性能影响
3. 更新文档

### 2.2 Git 工作流

**分支策略**:
```bash
# 主分支
master          # 稳定版本，用于发布
develop         # 开发主分支

# 功能分支
feature/xxx     # 新功能开发
bugfix/xxx      # Bug 修复
hotfix/xxx      # 紧急修复
```

**提交规范**:
```bash
# 提交类型
feat: 新功能
fix: Bug修复
docs: 文档更新
style: 代码格式化
refactor: 代码重构
test: 测试相关
chore: 构建工具、依赖更新

# 示例
git commit -m "feat: 添加HTML卡片渲染支持"
git commit -m "fix: 修复配偶布局重叠问题"
git commit -m "docs: 更新API文档"
```

**开发流程示例**:
```bash
# 1. 创建功能分支
git checkout -b feature/html-cards

# 2. 开发过程中的提交
git add .
git commit -m "feat: 添加HTML卡片基础结构"

# 3. 推送分支
git push origin feature/html-cards

# 4. 创建 Pull Request
# 5. 代码审查后合并到 develop
# 6. 删除功能分支
git branch -d feature/html-cards
```

### 2.3 测试驱动开发

**编写测试**:
```javascript
// tests/calculate-tree.test.js
describe('CalculateTree', () => {
  test('应该正确计算基础家族布局', () => {
    const data = [
      {id: 'father', data: {gender: 'M'}, rels: {children: ['child']}},
      {id: 'child', data: {gender: 'M'}, rels: {father: 'father'}}
    ];
    
    const result = CalculateTree({data, main_id: 'father'});
    
    expect(result.data).toHaveLength(2);
    expect(result.data[0].x).toBeCloseTo(0);
    expect(result.data[1].y).toBeGreaterThan(0);
  });
  
  test('应该正确处理配偶关系', () => {
    const data = [
      {id: 'husband', data: {gender: 'M'}, rels: {spouses: ['wife']}},
      {id: 'wife', data: {gender: 'F'}, rels: {spouses: ['husband']}}
    ];
    
    const result = CalculateTree({data, main_id: 'husband'});
    
    expect(result.data[0].spouses).toHaveLength(1);
    expect(Math.abs(result.data[0].x - result.data[0].spouses[0].x)).toBeGreaterThan(100);
  });
});
```

**运行测试**:
```bash
# 运行所有测试
npm test

# 运行特定测试文件
npm test -- tests/calculate-tree.test.js

# 观察模式运行
npm test -- --watch
```

## 3. 代码规范

### 3.1 JavaScript 编码规范

**变量命名**:
```javascript
// 使用有意义的变量名
const node_separation = 250;        // ✓ 好
const ns = 250;                     // ✗ 不好

// 常量使用大写
const DEFAULT_CARD_WIDTH = 220;     // ✓ 好
const default_width = 220;          // ✗ 不好

// 布尔值使用 is/has/can 前缀
const isHorizontal = true;          // ✓ 好
const horizontal = true;            // ✗ 不好
```

**函数设计**:
```javascript
// 单一职责原则
function calculateNodePosition(node, separation) {
  // 只负责位置计算
  return {x: node.depth * separation, y: node.level * separation};
}

// 避免过长的参数列表，使用配置对象
function CalculateTree({data, main_id, node_separation, level_separation}) {
  // 实现...
}

// 纯函数优先
function mergeSides(parents, children) {
  // 不修改输入参数，返回新对象
  return [...children, ...parents.slice(1)];
}
```

**错误处理**:
```javascript
function getDatum(id) {
  if (!id) {
    console.warn('getDatum: id 不能为空');
    return null;
  }
  
  const datum = data.find(d => d.id === id);
  if (!datum) {
    console.warn(`getDatum: 未找到 id 为 ${id} 的数据`);
  }
  
  return datum;
}
```

### 3.2 性能最佳实践

**避免不必要的重渲染**:
```javascript
// 使用缓存避免重复计算
const calculationCache = new Map();

function calcTree() {
  const cacheKey = `${JSON.stringify(state.data)}_${state.main_id}`;
  
  if (calculationCache.has(cacheKey)) {
    return calculationCache.get(cacheKey);
  }
  
  const result = CalculateTree({...});
  calculationCache.set(cacheKey, result);
  
  return result;
}
```

**DOM 操作优化**:
```javascript
// 批量 DOM 更新
function updateCards(svg, tree, Card, props) {
  // 使用 D3.js 的数据绑定，避免直接 DOM 操作
  const card = d3.select(svg)
    .selectAll("g.card_cont")
    .data(tree.data, d => d.data.id);  // 使用 key 函数提高性能
    
  // enter/update/exit 模式
  card.enter().append("g").attr("class", "card_cont");
  card.exit().remove();
  card.each(function(d) { Card.call(this, d); });
}
```

**内存泄漏防范**:
```javascript
// 清理事件监听器
function cleanupChart() {
  // 移除 D3.js 事件监听器
  d3.selectAll('.card_cont').on('.click', null);
  
  // 清理定时器
  if (animationTimer) {
    clearTimeout(animationTimer);
  }
  
  // 清理缓存
  calculationCache.clear();
}
```

### 3.3 模块化规范

**导入导出规范**:
```javascript
// 默认导出用于主要功能
export default function CalculateTree(config) {
  // 主要实现
}

// 命名导出用于辅助功能
export function sortChildrenWithSpouses(data) {
  // 辅助功能
}

export function createRelsToAdd(data) {
  // 辅助功能
}
```

**模块依赖管理**:
```javascript
// 明确的依赖关系
import d3 from "./d3.js"                    // 外部依赖
import {createNewPerson} from "../CreateTree/newPerson.js"  // 内部模块
import {isAllRelativeDisplayed} from "../handlers/general.js"  // 工具函数

// 避免循环依赖
// 如果 A 依赖 B，B 不应该依赖 A
```

## 4. 调试指南

### 4.1 开发调试技巧

**可视化调试**:
```javascript
// 在浏览器控制台中调试
window.debugFamily = {
  store: store,
  tree: tree,
  svg: svg,
  
  // 调试函数
  showCoordinates() {
    this.tree.data.forEach(d => {
      console.log(`${d.data.data["first name"]}: (${d.x}, ${d.y})`);
    });
  },
  
  highlightNode(id) {
    const node = this.tree.data.find(d => d.data.id === id);
    if (node) {
      d3.select(`[data-id="${id}"]`).style('stroke', 'red').style('stroke-width', 5);
    }
  },
  
  showRelationships(id) {
    const person = this.store.getDatum(id);
    console.table(person.rels);
  }
};
```

**断点调试**:
```javascript
function CalculateTree({data, main_id, ...config}) {
  debugger;  // 在关键点设置断点
  
  const tree_children = calculateTreePositions(main, 'children', false);
  console.log('Children tree:', tree_children);  // 输出中间结果
  
  const tree_parents = calculateTreePositions(main, 'parents', true);
  console.log('Parents tree:', tree_parents);
  
  return result;
}
```

**性能分析**:
```javascript
function profileRender() {
  console.time('树布局计算');
  const tree = CalculateTree({...});
  console.timeEnd('树布局计算');
  
  console.time('DOM渲染');
  f3.view(tree, svg, card.getCard(), props);
  console.timeEnd('DOM渲染');
}
```

### 4.2 常见问题诊断

**布局问题**:
```javascript
// 检查数据完整性
function validateTreeData(tree) {
  const issues = [];
  
  tree.data.forEach(node => {
    if (!node.x || !node.y) {
      issues.push(`节点 ${node.data.id} 缺少坐标`);
    }
    
    if (node.spouses) {
      node.spouses.forEach(spouse => {
        if (!spouse.x || !spouse.y) {
          issues.push(`配偶节点坐标异常: ${JSON.stringify(spouse)}`);
        }
      });
    }
  });
  
  return issues;
}
```

**性能问题**:
```javascript
// 监控渲染性能
const performanceObserver = new PerformanceObserver((list) => {
  list.getEntries().forEach(entry => {
    if (entry.name.includes('family-chart')) {
      console.log(`${entry.name}: ${entry.duration}ms`);
    }
  });
});

performanceObserver.observe({entryTypes: ['measure']});

// 在关键代码段添加性能标记
performance.mark('tree-calculation-start');
const tree = CalculateTree({...});
performance.mark('tree-calculation-end');
performance.measure('tree-calculation', 'tree-calculation-start', 'tree-calculation-end');
```

### 4.3 错误处理策略

**优雅降级**:
```javascript
function safeCalculateTree(config) {
  try {
    return CalculateTree(config);
  } catch (error) {
    console.error('树布局计算失败:', error);
    
    // 返回最小可用结果
    return {
      data: config.data.map((d, i) => ({
        ...d,
        x: i * 250,
        y: 0
      })),
      dim: {width: config.data.length * 250, height: 100}
    };
  }
}
```

**错误边界**:
```javascript
class FamilyChartErrorBoundary {
  constructor(container) {
    this.container = container;
    this.hasError = false;
  }
  
  wrap(renderFunction) {
    return (...args) => {
      try {
        if (this.hasError) {
          this.recover();
        }
        return renderFunction.apply(this, args);
      } catch (error) {
        this.handleError(error);
      }
    };
  }
  
  handleError(error) {
    console.error('Family Chart 渲染错误:', error);
    this.hasError = true;
    this.showErrorMessage();
  }
  
  showErrorMessage() {
    this.container.innerHTML = `
      <div class="error-message">
        <h3>家谱图渲染失败</h3>
        <p>请检查数据格式或刷新页面重试</p>
        <button onclick="location.reload()">刷新页面</button>
      </div>
    `;
  }
  
  recover() {
    this.hasError = false;
    this.container.innerHTML = '';
  }
}
```

## 5. 发布流程

### 5.1 版本管理

**版本号规范** (语义化版本):
```
主版本号.次版本号.修订号

1.0.0 → 1.0.1  # 修复bug
1.0.1 → 1.1.0  # 新增功能，向后兼容
1.1.0 → 2.0.0  # 破坏性更改
```

**发布前检查清单**:
- [ ] 所有测试通过
- [ ] 代码审查完成
- [ ] 文档更新完整
- [ ] 版本号正确递增
- [ ] 构建文件正常生成
- [ ] 浏览器兼容性测试

### 5.2 构建发布

**构建命令**:
```bash
# 清理旧文件
rm -rf dist/

# 执行构建
npm run build

# 验证构建结果
ls -la dist/
```

**构建配置检查**:
```javascript
// rollup.config.js
export default [
  // UMD 构建 - 浏览器直接使用
  {
    input: "src/index.js",
    output: {
      file: "dist/family-chart.js",
      format: "umd",
      name: "f3"
    }
  },
  // ES 模块构建 - 现代打包工具使用
  {
    input: "src/index.js", 
    output: {
      file: "dist/family-chart.esm.js",
      format: "es"
    }
  },
  // 压缩版本
  {
    input: "src/index.js",
    output: {
      file: "dist/family-chart.min.js",
      format: "umd",
      name: "f3"
    },
    plugins: [terser()]
  }
];
```

### 5.3 CI/CD 集成

**GitHub Actions 示例**:
```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [master, develop]
  pull_request:
    branches: [master]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '16'
      - run: npm ci
      - run: npm test
      - run: npm run build
      
  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '16'
      - run: npm ci
      - run: npm run build
      - run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{secrets.NPM_TOKEN}}
```

## 6. 协作开发

### 6.1 团队协作规范

**代码审查要点**:
1. **功能正确性**: 是否满足需求
2. **代码质量**: 是否遵循规范
3. **性能影响**: 是否有性能问题
4. **向后兼容**: 是否破坏现有API
5. **测试覆盖**: 是否有充分测试

**Pull Request 模板**:
```markdown
## 变更描述
简要描述本次改动的内容和目的

## 变更类型
- [ ] Bug修复
- [ ] 新功能
- [ ] 代码重构
- [ ] 文档更新
- [ ] 测试相关

## 测试计划
- [ ] 现有测试全部通过
- [ ] 添加了新的单元测试
- [ ] 在示例中手动验证
- [ ] 跨浏览器测试

## 破坏性变更
- [ ] 此变更包含破坏性更改
- [ ] 已更新相关文档
- [ ] 已提供迁移指南

## 相关issue
修复 #123
关联 #456
```

### 6.2 文档维护

**文档更新要求**:
1. API 变更必须更新文档
2. 新功能需要添加使用示例
3. 重要修改需要更新 CHANGELOG
4. 破坏性变更需要迁移指南

**示例文档模板**:
```markdown
## setCardDim(cardDim)

设置卡片的尺寸参数。

### 参数
- `cardDim` (Object): 卡片尺寸配置
  - `w` (Number): 卡片宽度，默认220
  - `h` (Number): 卡片高度，默认70
  - `text_x` (Number): 文字X偏移，默认75
  - `text_y` (Number): 文字Y偏移，默认15

### 返回值
- (CardSvg): 返回卡片实例，支持链式调用

### 示例
```javascript
card.setCardDim({
  w: 250,
  h: 80,
  text_x: 10,
  text_y: 20
});
```

### 变更历史
- v1.2.0: 新增功能
- v1.3.0: 添加链式调用支持
```

### 6.3 社区贡献

**贡献指南**:
1. Fork 项目到个人账号
2. 创建功能分支进行开发
3. 遵循代码规范和提交规范
4. 添加必要的测试和文档
5. 提交 Pull Request

**Issue 处理流程**:
1. **分类标记**: bug/enhancement/question
2. **优先级评估**: high/medium/low
3. **分配责任人**: 确定处理人员
4. **进度跟踪**: 定期更新状态
5. **验证关闭**: 确认修复后关闭

## 7. 总结

遵循本开发流程指南，可以确保：

1. **代码质量**: 通过规范和审查保证代码质量
2. **开发效率**: 通过工具和流程提高开发效率  
3. **团队协作**: 通过统一标准促进团队协作
4. **产品稳定**: 通过测试和发布流程保证产品稳定

持续改进开发流程，让Family Chart项目更加健壮和易于维护！